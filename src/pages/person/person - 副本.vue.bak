<template>
  <div id="app" class="person">    
    <!-- <div><router-link :to="{name:'/add'}">去注册</router-link></div>
    <router-link :to="{name:'home',params: { userId: 123 }}">返回首页</router-link> -->
    <div class="container"></div>
    <div class="login-box">
      <h1>登录</h1>
    </div>
      <!-- <router-view/> -->
  </div>
</template>
<script>
import remjs from "util/rem";
import * as THREE from 'three'
// import Stats from 'three/examples/jsm/libs/stats.module.js';

  var SEPARATION = 30, AMOUNTX = 50, AMOUNTY = 50;
  var container, stats;
  var camera, scene, renderer;
  var particles, count = 0;
  var mouseX = 0, mouseY = 0;
  var windowHalfX = window.innerWidth / 2;
  var windowHalfY = window.innerHeight / 2;


export default {
  data() {
    return {
      
    }
  },
  mounted() {
    
 
    this.$nextTick(() =>{
      this.init()
      this.animate()

    })

  },
  methods: {
    init(){
      container = document.createElement( 'div' );
		document.body.appendChild( container );
       camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 1000;
				scene = new THREE.Scene();
				//
				var numParticles = AMOUNTX * AMOUNTY;
				var positions = new Float32Array( numParticles * 3 );
				var scales = new Float32Array( numParticles );
				var i = 0, j = 0;
				for ( var ix = 0; ix < AMOUNTX; ix ++ ) {
					for ( var iy = 0; iy < AMOUNTY; iy ++ ) {
						positions[ i ] = ix * SEPARATION - ( ( AMOUNTX * SEPARATION ) / 2 ); // x
						positions[ i + 1 ] = 0; // y
						positions[ i + 2 ] = iy * SEPARATION - ( ( AMOUNTY * SEPARATION ) / 2 ); // z
						scales[ j ] = 1;
						i += 3;
						j ++;
					}
				}
				var geometry = new THREE.BufferGeometry();
				geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.setAttribute( 'scale', new THREE.BufferAttribute( scales, 1 ) );
				var material = new THREE.ShaderMaterial( {
					uniforms: {
						color: { value: new THREE.Color( 0xffffff ) },
					},
					// vertexShader: document.getElementById( 'vertexshader' ).textContent,
					// fragmentShader: document.getElementById( 'fragmentshader' ).textContent
				} );
				//
				particles = new THREE.Points( geometry, material );
				scene.add( particles );
				//
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				// stats = new Stats();
				// container.appendChild( stats.dom );
				// document.addEventListener( 'mousemove', this.onDocumentMouseMove, false );
				// document.addEventListener( 'touchstart', this.onDocumentTouchStart, false );
				// document.addEventListener( 'touchmove', this.onDocumentTouchMove, false );
				//
				window.addEventListener( 'resize', this.onWindowResize, false );

    },
    onWindowResize(){
        windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
    },
    onDocumentMouseMove(event) {
      mouseX = event.clientX - windowHalfX;
			mouseY = event.clientY - windowHalfY;
    },
    onDocumentTouchStart(event) {
      if ( event.touches.length === 1 ) {
					event.preventDefault();
					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;
				}
    },
    onDocumentTouchMove(event) {
      if ( event.touches.length === 1 ) {
					event.preventDefault();
					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;
				}
    },   
    animate() {
      requestAnimationFrame( this.animate );
				this.render();
				// stats.update();
    },
    render() {
      camera.position.x += ( mouseX - camera.position.x ) * .05;
				camera.position.y += ( - mouseY - camera.position.y ) * .05;
				camera.lookAt( scene.position );
				var positions = particles.geometry.attributes.position.array;
				var scales = particles.geometry.attributes.scale.array;
				var i = 0, j = 0;
				for ( var ix = 0; ix < AMOUNTX; ix ++ ) {
					for ( var iy = 0; iy < AMOUNTY; iy ++ ) {
						positions[ i + 1 ] = ( Math.sin( ( ix + count ) * 0.3 ) * 50 ) +
										( Math.sin( ( iy + count ) * 0.5 ) * 50 );
						scales[ j ] = ( Math.sin( ( ix + count ) * 0.3 ) + 1 ) * 8 +
										( Math.sin( ( iy + count ) * 0.5 ) + 1 ) * 8;
						i += 3;
						j ++;
					}
				}
				particles.geometry.attributes.position.needsUpdate = true;
				particles.geometry.attributes.scale.needsUpdate = true;
				renderer.render( scene, camera );
				count += 0.1;
    }

  },
}
</script>
export default {
  
}
</script>
<style lang="less">
  .person{
    font-size: 20px;
    // &:extend(.co-flex);
    // position: relative;
    .login-box:extend(.co-dom-center){
      // .co-dom-center2(600px,600px);
      width:600px;
      height:600px;
      border: 1px solid red;
    }
  }

</style>
